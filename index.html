<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shelf Measure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #f5f5f5;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #canvas-container {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        #controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #controls label {
            font-size: 14px;
            color: #333;
        }
        #controls input {
            width: 120px;
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        #controls span {
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="shelf-canvas"></canvas>
    </div>
    <div id="controls">
        <label for="pipe-distance">Pipe Distance:</label>
        <input type="number" id="pipe-distance" step="0.00001" value="28.96875">
        <span>inches</span>
        <button id="view-toggle" style="margin-left: 20px; padding: 6px 12px; border: 1px solid #ccc; border-radius: 4px; background: #fff; cursor: pointer;">View: Top</button>
    </div>
    <div id="clearance-info" style="margin-top: 10px; font-size: 12px; display: flex; gap: 20px;">
        <span id="clearance-left">Nut clearance (L): --</span>
        <span id="clearance-right">Nut clearance (R): --</span>
    </div>

    <script>
        // ============================================
        // CONFIG - All measurements in inches
        // ============================================
        const CONFIG = {
            shelf: {
                width: 30,
                depth: 12,
                height: 1  // For front view
            },
            pipe: {
                diameter: 1.0743,
                length: 13,
                overhang: 0.5  // How much pipe extends beyond shelf top/bottom
            },
            bracket: {
                // All measurements converted from mm to inches
                width: 38 / 25.4,           // 38mm = 1.4961"
                length: 60 / 25.4,          // 60mm = 2.3622" (along pipe)
                thickness: 1.5 / 25.4,      // 1.5mm = 0.05906"
                holeCenter: 8 / 25.4,       // 8mm from edge to hole center = 0.31496"
                holeDiameter: 4.5 / 25.4,   // 4.5mm = 0.17717"
                holeClearance: 1 / 16       // Keep holes this far inside/outside shelf edges
            },
            hardware: {
                // M4-0.7 x 8mm ISO 7380 Button Head Cap Screw
                buttonScrew: {
                    headDiameter: 7.6 / 25.4,    // 7.6mm typical for M4 button head
                    headHeight: 2.2 / 25.4       // 2.2mm typical height
                },
                // M4 Brass Hex Cap Nut
                hexCapNut: {
                    acrossFlats: 4.9 / 25.4,     // 4.9mm AF
                    acrossCorners: 7.9 / 25.4,   // 7.9mm AC (corner-to-corner)
                    height: 9.3 / 25.4           // 9.3mm total height
                },
                // Clearance requirements
                nutPipeClearance: {
                    target: 1.25 / 25.4,         // Target gap: 1.25mm (middle of 1.0-1.5 range)
                    minimum: 1.0 / 25.4          // Minimum acceptable: 1.0mm
                }
            },
            precision: 5,
            mmPerInch: 25.4,
            layout: {
                // Bracket placement along shelf depth
                // mode: 'golden' uses golden ratio on the free space after subtracting bracket lengths
                mode: 'golden',
                phi: (1 + Math.sqrt(5)) / 2
            },
            display: {
                padding: 40,        // Canvas padding in pixels
                minCanvasWidth: 600,
                minCanvasHeight: 300
            },
            colors: {
                shelf: '#d4a574',
                shelfStroke: '#8b6914',
                pipe: '#6b7b8a',
                pipeStroke: '#3d4a54',
                bracket: '#2d2d2d',
                bracketStroke: '#1a1a1a',
                bracketHole: '#ffffff',
                background: '#ffffff',
                // Hardware colors
                buttonScrewHead: '#4a4a4a',
                buttonScrewHeadStroke: '#2d2d2d',
                buttonScrewSocket: '#1a1a1a',
                hexNut: '#b8860b',           // Brass color
                hexNutStroke: '#8b6914'
            }
        };

        // ============================================
        // STATE - Mutable application state
        // ============================================
        const State = {
            pipeDistance: 28.96875,  // Distance between inner edges of pipes
            shelfOpacity: 1.0,       // 1.0 or 0.5
            view: 'top'              // 'top' or 'front'
        };

        // ============================================
        // UNITS MODULE - Conversion utilities
        // ============================================
        const Units = {
            /**
             * Convert inches to millimeters
             * @param {number} inches
             * @returns {number}
             */
            toMm(inches) {
                return inches * CONFIG.mmPerInch;
            },

            /**
             * Convert millimeters to inches
             * @param {number} mm
             * @returns {number}
             */
            toInches(mm) {
                return mm / CONFIG.mmPerInch;
            },

            /**
             * Format a value with precision
             * @param {number} value
             * @param {string} unit - 'in' or 'mm'
             * @returns {string}
             */
            format(value, unit = 'in') {
                const formatted = value.toFixed(CONFIG.precision);
                return `${formatted} ${unit}`;
            },

            /**
             * Format inches value, optionally showing both units
             * @param {number} inches
             * @param {boolean} showBoth
             * @returns {string}
             */
            formatInches(inches, showBoth = false) {
                if (showBoth) {
                    const mm = this.toMm(inches);
                    return `${inches.toFixed(CONFIG.precision)}" (${mm.toFixed(CONFIG.precision)} mm)`;
                }
                return `${inches.toFixed(CONFIG.precision)}"`;
            }
        };

        // ============================================
        // LAYOUT MODULE - Bracket placement helpers
        // ============================================
        const Layout = {
            /**
             * Compute symmetric inset from shelf edges to bracket edges (top/bottom), along shelf depth.
             * Uses golden ratio on the *free* depth after subtracting the two bracket lengths:
             *   depth = 2*inset + 2*L + gap
             *   gap / (2*inset) = phi
             * => inset = (depth - 2*L) / (2*(1+phi))
             *
             * Returns 0 when configuration or geometry makes the calculation invalid.
             */
            bracketInsetDepth() {
                const depth = CONFIG.shelf.depth;
                const L = CONFIG.bracket.length;
                const phi = CONFIG.layout?.phi ?? ((1 + Math.sqrt(5)) / 2);

                // If we're not in golden mode, default to 0 inset (flush)
                if ((CONFIG.layout?.mode ?? 'golden') !== 'golden') return 0;

                const free = depth - 2 * L;
                if (free <= 0) return 0;

                const inset = free / (2 * (1 + phi));

                // Guard against weirdness
                if (!Number.isFinite(inset) || inset < 0) return 0;

                return inset;
            },

            /**
             * Return the Y (in inches) for a bracket's top-left corner in TOP view.
             * position: 'top' | 'bottom'
             */
            bracketYTopView(position) {
                const inset = this.bracketInsetDepth();
                const depth = CONFIG.shelf.depth;
                const L = CONFIG.bracket.length;

                if (position === 'top') return inset;
                return depth - inset - L;
            },

            /**
             * Calculate the minimum bracket shift needed for button head to clear shelf edge.
             * @returns {number} minimum shift in inches
             */
            minShiftForButtonHeadClearance() {
                const b = CONFIG.bracket;
                const hw = CONFIG.hardware;
                const shelfOverhang = (CONFIG.shelf.width - State.pipeDistance) / 2;
                const holeCenterFromBracketCenter = b.width / 2 - b.holeCenter;
                const buttonHeadRadius = hw.buttonScrew.headDiameter / 2;

                // For left bracket:
                // outerHoleX = -shift - holeCenterFromBracketCenter
                // Button head outer edge = outerHoleX + buttonHeadRadius
                // Must be outside shelf: outerHoleX + buttonHeadRadius < -shelfOverhang
                // -shift - holeCenterFromBracketCenter + buttonHeadRadius < -shelfOverhang
                // -shift < -shelfOverhang + holeCenterFromBracketCenter - buttonHeadRadius
                // shift > shelfOverhang - holeCenterFromBracketCenter + buttonHeadRadius

                return shelfOverhang - holeCenterFromBracketCenter + buttonHeadRadius + b.holeClearance;
            },

            /**
             * Calculate the minimum bracket shift needed for nut to clear pipe horizontally.
             * The nut's inner edge (closest to pipe) must be outside the pipe's radius.
             * @returns {number} minimum shift in inches
             */
            minShiftForNutClearance() {
                const hw = CONFIG.hardware;
                const pipeRadius = CONFIG.pipe.diameter / 2;
                const holeCenterFromBracketCenter = CONFIG.bracket.width / 2 - CONFIG.bracket.holeCenter;
                // Use across-flats/2 for the inner edge of the nut (flat facing pipe is best case)
                const nutInnerRadius = hw.hexCapNut.acrossFlats / 2;

                // For left bracket:
                // outerHoleX = -shift - holeCenterFromBracketCenter
                // Nut inner edge = outerHoleX + nutInnerRadius (closer to center)
                // Must be outside pipe: nutInnerEdge <= -pipeRadius
                // -shift - holeCenterFromBracketCenter + nutInnerRadius <= -pipeRadius
                // -shift <= -pipeRadius + holeCenterFromBracketCenter - nutInnerRadius
                // shift >= pipeRadius - holeCenterFromBracketCenter + nutInnerRadius

                return pipeRadius - holeCenterFromBracketCenter + nutInnerRadius + hw.nutPipeClearance.target;
            },

            /**
             * Calculate the maximum bracket shift allowed so inner holes stay over the wood.
             * Inner holes must not extend past the pipe center line (x=0 for left pipe).
             * @returns {number} maximum shift in inches
             */
            maxShiftForInnerHoles() {
                const holeCenterFromBracketCenter = CONFIG.bracket.width / 2 - CONFIG.bracket.holeCenter;

                // For left bracket:
                // innerHoleX = -shift + holeCenterFromBracketCenter
                // Must stay right of pipe center (x=0): innerHoleX >= 0
                // -shift + holeCenterFromBracketCenter >= 0
                // shift <= holeCenterFromBracketCenter

                return holeCenterFromBracketCenter;
            },

            /**
             * Calculate actual nut-to-pipe clearance for current bracket position
             * @param {boolean} isLeft - true for left bracket
             * @param {number} shift - the bracket shift value being used
             * @returns {object} { clearance, isOk, required }
             */
            nutToPipeClearance(isLeft, shift) {
                const hw = CONFIG.hardware;
                const b = CONFIG.bracket;
                const pipeRadius = CONFIG.pipe.diameter / 2;
                const holeCenterFromBracketCenter = b.width / 2 - b.holeCenter;
                const nutInnerRadius = hw.hexCapNut.acrossFlats / 2;

                // Calculate outer hole position
                const pipeCenter = isLeft ? 0 : State.pipeDistance;
                const bracketCenterX = isLeft ? pipeCenter - shift : pipeCenter + shift;
                const outerHoleX = isLeft
                    ? bracketCenterX - holeCenterFromBracketCenter
                    : bracketCenterX + holeCenterFromBracketCenter;

                // Nut inner edge (closest to pipe)
                const nutInnerEdgeX = isLeft
                    ? outerHoleX + nutInnerRadius
                    : outerHoleX - nutInnerRadius;

                // Pipe outer edge
                const pipeOuterEdge = isLeft ? -pipeRadius : State.pipeDistance + pipeRadius;

                // Clearance (gap between nut inner edge and pipe outer edge)
                const clearance = isLeft
                    ? pipeOuterEdge - nutInnerEdgeX  // How far nut is from pipe (negative = overlapping)
                    : nutInnerEdgeX - pipeOuterEdge;

                // Note: negative clearance means nut is outside pipe (good!)
                // We want the nut to NOT overlap with pipe horizontally
                return {
                    clearance: Math.abs(clearance),
                    isOk: (isLeft ? nutInnerEdgeX <= pipeOuterEdge : nutInnerEdgeX >= pipeOuterEdge),
                    required: hw.nutPipeClearance.target
                };
            },

            /**
             * Calculate the optimal bracket shift that satisfies all constraints:
             * 1. Button head clears shelf edge (min shift)
             * 2. Nut clears pipe horizontally (min shift)
             * 3. Inner holes stay over wood/pipe center (max shift)
             * @returns {object} { shift, minShift, maxShift, hasConflict }
             */
            optimalShift() {
                // Calculate constraints
                const minShiftButtonHead = this.minShiftForButtonHeadClearance();
                const minShiftNut = this.minShiftForNutClearance();
                const maxShiftInnerHoles = this.maxShiftForInnerHoles();

                const minShift = Math.max(minShiftButtonHead, minShiftNut);
                const maxShift = maxShiftInnerHoles;

                // Check for conflict (min > max means impossible geometry)
                const hasConflict = minShift > maxShift;

                // Use the minimum required shift (or max if there's conflict)
                const shift = hasConflict ? maxShift : minShift;

                return {
                    shift: shift,
                    minShift: minShift,
                    maxShift: maxShift,
                    minShiftButtonHead: minShiftButtonHead,
                    minShiftNut: minShiftNut,
                    hasConflict: hasConflict
                };
            }
        };

        // ============================================
        // RENDERER MODULE - Canvas drawing
        // ============================================
        const Renderer = {
            canvas: null,
            ctx: null,
            scale: 1,       // Pixels per inch
            offsetX: 0,     // Offset to center drawing
            offsetY: 0,

            // Cached shelf bounds for click detection
            shelfBounds: { x: 0, y: 0, width: 0, height: 0 },

            /**
             * Initialize the renderer
             */
            init() {
                this.canvas = document.getElementById('shelf-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.calculateDimensions();
                this.setupClickHandler();
            },

            /**
             * Setup click handler for shelf opacity toggle
             */
            setupClickHandler() {
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Check if click is within shelf bounds
                    if (x >= this.shelfBounds.x &&
                        x <= this.shelfBounds.x + this.shelfBounds.width &&
                        y >= this.shelfBounds.y &&
                        y <= this.shelfBounds.y + this.shelfBounds.height) {
                        // Toggle opacity
                        State.shelfOpacity = State.shelfOpacity === 1.0 ? 0.5 : 1.0;
                        this.render();
                    }
                });

                // Change cursor when hovering over shelf
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (x >= this.shelfBounds.x &&
                        x <= this.shelfBounds.x + this.shelfBounds.width &&
                        y >= this.shelfBounds.y &&
                        y <= this.shelfBounds.y + this.shelfBounds.height) {
                        this.canvas.style.cursor = 'pointer';
                    } else {
                        this.canvas.style.cursor = 'default';
                    }
                });
            },

            /**
             * Calculate canvas size and scale
             */
            calculateDimensions() {
                const pipeRadius = CONFIG.pipe.diameter / 2;

                // Total width = pipe distance + full diameter on each side (for the pipes extending outside)
                const totalWidth = State.pipeDistance + CONFIG.pipe.diameter;

                // Total height depends on view
                let totalHeight;
                if (State.view === 'top') {
                    // Brackets are now fully under the shelf, so just pipe length
                    totalHeight = CONFIG.pipe.length;
                } else {
                    // Front view: bracket thickness + pipe diameter + shelf height
                    totalHeight = CONFIG.bracket.thickness + CONFIG.pipe.diameter + CONFIG.shelf.height;
                }

                // Calculate scale to fit within viewport with padding
                const availableWidth = Math.max(window.innerWidth - 100, CONFIG.display.minCanvasWidth);
                const availableHeight = Math.max(window.innerHeight - 150, CONFIG.display.minCanvasHeight);

                const scaleX = (availableWidth - CONFIG.display.padding * 2) / totalWidth;
                const scaleY = (availableHeight - CONFIG.display.padding * 2) / totalHeight;
                this.scale = Math.min(scaleX, scaleY);

                // Set canvas size (use integers to avoid blur)
                this.canvas.width = Math.round(totalWidth * this.scale + CONFIG.display.padding * 2);
                this.canvas.height = Math.round(totalHeight * this.scale + CONFIG.display.padding * 2);

                // Offset so that x=0 is at the left pipe's inner edge
                this.offsetX = CONFIG.display.padding + pipeRadius * this.scale;

                if (State.view === 'top') {
                    this.offsetY = CONFIG.display.padding + CONFIG.pipe.overhang * this.scale;
                } else {
                    // Front view: y=0 is at top of pipe circles
                    // Bracket sits above pipe (at -thickness), shelf sits above bracket
                    this.offsetY = CONFIG.display.padding + (CONFIG.bracket.thickness + CONFIG.shelf.height) * this.scale;
                }
            },

            /**
             * Convert inches to canvas pixels (X coordinate) - returns rounded integer
             * @param {number} inches
             * @returns {number}
             */
            toPixelX(inches) {
                return Math.round(this.offsetX + inches * this.scale);
            },

            /**
             * Convert inches to canvas pixels (Y coordinate) - returns rounded integer
             * @param {number} inches
             * @returns {number}
             */
            toPixelY(inches) {
                return Math.round(this.offsetY + inches * this.scale);
            },

            /**
             * Convert inches to pixels (for dimensions) - returns rounded integer
             * @param {number} inches
             * @returns {number}
             */
            toPixels(inches) {
                return Math.round(inches * this.scale);
            },

            /**
             * Clear the canvas
             */
            clear() {
                this.ctx.fillStyle = CONFIG.colors.background;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            },

            /**
             * Draw a crisp rectangle (for fills)
             */
            fillRect(x, y, width, height, color) {
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x, y, width, height);
            },

            /**
             * Draw a crisp stroked rectangle
             * Offset by 0.5 to align stroke to pixel grid
             */
            strokeRect(x, y, width, height, color, lineWidth) {
                const ctx = this.ctx;
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                // Offset by 0.5 for crisp 1px lines
                const offset = lineWidth % 2 === 1 ? 0.5 : 0;
                ctx.strokeRect(x + offset, y + offset, width, height);
            },

            /**
             * Draw a hexagon (for button screw socket or nut)
             * @param {number} cx - Center X in pixels
             * @param {number} cy - Center Y in pixels
             * @param {number} radius - Radius (to vertex) in pixels
             * @param {string} fillColor
             * @param {string} strokeColor (optional)
             */
            drawHexagon(cx, cy, radius, fillColor, strokeColor = null) {
                const ctx = this.ctx;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 2; // Start at top vertex
                    const x = cx + radius * Math.cos(angle);
                    const y = cy + radius * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fillStyle = fillColor;
                ctx.fill();
                if (strokeColor) {
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            },

            /**
             * Draw a single pipe
             * @param {number} xInnerEdge - X position of the pipe's inner edge in inches
             */
            drawPipe(xInnerEdge) {
                const pipeRadius = CONFIG.pipe.diameter / 2;

                // Pipe position: inner edge at xInnerEdge
                const x = this.toPixelX(xInnerEdge - pipeRadius);
                const y = this.toPixelY(-CONFIG.pipe.overhang);
                const width = this.toPixels(CONFIG.pipe.diameter);
                const height = this.toPixels(CONFIG.pipe.length);

                this.fillRect(x, y, width, height, CONFIG.colors.pipe);
                this.strokeRect(x, y, width, height, CONFIG.colors.pipeStroke, 1);
            },

            /**
             * Draw both pipe supports
             */
            drawPipes() {
                // Left pipe: inner edge at x = 0
                this.drawPipe(0);

                // Right pipe: inner edge at x = pipeDistance
                this.drawPipe(State.pipeDistance);
            },

            /**
             * Draw center line on a pipe
             * @param {number} xInnerEdge - X position of the pipe's inner edge in inches
             */
            drawPipeCenterLine(xInnerEdge) {
                const ctx = this.ctx;
                const pipeRadius = CONFIG.pipe.diameter / 2;

                // Center of pipe
                const x = Math.round(this.toPixelX(xInnerEdge)) + 0.5; // 0.5 offset for crisp 1px line
                const yStart = this.toPixelY(-CONFIG.pipe.overhang);
                const yEnd = this.toPixelY(-CONFIG.pipe.overhang + CONFIG.pipe.length);

                ctx.beginPath();
                ctx.moveTo(x, yStart);
                ctx.lineTo(x, yEnd);
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 1;
                ctx.stroke();
            },

            /**
             * Draw center lines on both pipes (top view)
             */
            drawPipeCenterLines() {
                // Left pipe center line
                this.drawPipeCenterLine(0);

                // Right pipe center line
                this.drawPipeCenterLine(State.pipeDistance);
            },

            // ========== FRONT VIEW METHODS ==========

            /**
             * Draw a pipe as a circle (front view)
             * @param {number} xInnerEdge - X position of the pipe's inner edge in inches
             */
            drawPipeCircle(xInnerEdge) {
                const ctx = this.ctx;
                const pipeRadius = CONFIG.pipe.diameter / 2;

                // Circle center
                const cx = this.toPixelX(xInnerEdge);
                const cy = this.toPixelY(pipeRadius);
                const r = this.toPixels(pipeRadius);

                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fillStyle = CONFIG.colors.pipe;
                ctx.fill();
                ctx.strokeStyle = CONFIG.colors.pipeStroke;
                ctx.lineWidth = 1;
                ctx.stroke();
            },

            /**
             * Draw both pipe circles (front view)
             */
            drawPipeCircles() {
                this.drawPipeCircle(0);
                this.drawPipeCircle(State.pipeDistance);
            },

            /**
             * Draw center line on a pipe circle (front view) - vertical line through center
             * @param {number} xInnerEdge - X position of the pipe's inner edge in inches
             */
            drawPipeCircleCenterLine(xInnerEdge) {
                const ctx = this.ctx;
                const pipeRadius = CONFIG.pipe.diameter / 2;

                const x = Math.round(this.toPixelX(xInnerEdge)) + 0.5;
                const yStart = this.toPixelY(0);
                const yEnd = this.toPixelY(CONFIG.pipe.diameter);

                ctx.beginPath();
                ctx.moveTo(x, yStart);
                ctx.lineTo(x, yEnd);
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 1;
                ctx.stroke();
            },

            /**
             * Draw center lines on both pipe circles (front view)
             */
            drawPipeCircleCenterLines() {
                this.drawPipeCircleCenterLine(0);
                this.drawPipeCircleCenterLine(State.pipeDistance);
            },

            /**
             * Draw shelf in front view (rectangle above pipes and brackets)
             */
            drawShelfFront() {
                const ctx = this.ctx;

                // Shelf is centered between pipes
                const shelfOverhang = (CONFIG.shelf.width - State.pipeDistance) / 2;
                const shelfX = -shelfOverhang;

                const x = this.toPixelX(shelfX);
                // Shelf sits above the bracket (which is above the pipe)
                const y = this.toPixelY(-CONFIG.bracket.thickness - CONFIG.shelf.height);
                const width = this.toPixels(CONFIG.shelf.width);
                const height = this.toPixels(CONFIG.shelf.height);

                // Store bounds for click detection
                this.shelfBounds = { x, y, width, height };

                // Apply opacity
                ctx.globalAlpha = State.shelfOpacity;
                this.fillRect(x, y, width, height, CONFIG.colors.shelf);
                // Draw stroke INSIDE the shelf bounds (inset by half stroke width)
                const strokeWidth = 2;
                const inset = strokeWidth / 2;
                ctx.strokeStyle = CONFIG.colors.shelfStroke;
                ctx.lineWidth = strokeWidth;
                ctx.strokeRect(x + inset, y + inset, width - strokeWidth, height - strokeWidth);
                ctx.globalAlpha = 1.0;
            },

            // ========== BRACKET METHODS ==========

            /**
             * Draw a bracket in top view (rectangle with 4 holes)
             * @param {number} xPipeInnerEdge - X position of the pipe's inner edge in inches
             * @param {string} position - 'top' or 'bottom' edge of shelf
             * @param {boolean} isLeft - true for left pipe brackets, false for right
             */
            drawBracketTop(xPipeInnerEdge, position, isLeft) {
                const ctx = this.ctx;
                const b = CONFIG.bracket;
                const hw = CONFIG.hardware;

                // Get optimal shift from Layout module (considers both shelf edge and nut clearance)
                const shiftInfo = Layout.optimalShift();
                const shift = shiftInfo.shift;

                let bracketCenterX;
                if (isLeft) {
                    bracketCenterX = xPipeInnerEdge - shift;  // Shift left
                } else {
                    bracketCenterX = xPipeInnerEdge + shift;  // Shift right
                }
                const bracketX = bracketCenterX - b.width / 2;

                // Bracket is fully under the shelf, positioned along depth
                // Default uses golden ratio inset (see Layout module)
                const bracketY = Layout.bracketYTopView(position);

                const x = this.toPixelX(bracketX);
                const y = this.toPixelY(bracketY);
                const width = this.toPixels(b.width);
                const height = this.toPixels(b.length);

                // Draw bracket rectangle
                this.fillRect(x, y, width, height, CONFIG.colors.bracket);
                this.strokeRect(x, y, width, height, CONFIG.colors.bracketStroke, 1);

                // Draw 4 holes (2x2 pattern)
                // Holes are 8mm from each edge
                const holeRadiusPixels = this.toPixels(b.holeDiameter / 2);
                const holeOffsetX = b.holeCenter;  // From bracket edge
                const holeOffsetY = b.holeCenter;  // From bracket edge

                // Hole positions relative to bracket top-left
                // [0] Top-left, [1] Top-right, [2] Bottom-left, [3] Bottom-right
                const holes = [
                    { x: bracketX + holeOffsetX, y: bracketY + holeOffsetY },                           // Top-left
                    { x: bracketX + b.width - holeOffsetX, y: bracketY + holeOffsetY },                 // Top-right
                    { x: bracketX + holeOffsetX, y: bracketY + b.length - holeOffsetY },                // Bottom-left
                    { x: bracketX + b.width - holeOffsetX, y: bracketY + b.length - holeOffsetY }       // Bottom-right
                ];

                // Outer holes (outside shelf edge, get button screws):
                // Left brackets: left column = indices [0, 2]
                // Right brackets: right column = indices [1, 3]
                const outerHoleIndices = isLeft ? [0, 2] : [1, 3];

                // Draw holes first
                ctx.fillStyle = CONFIG.colors.bracketHole;
                holes.forEach((hole, index) => {
                    ctx.beginPath();
                    ctx.arc(this.toPixelX(hole.x), this.toPixelY(hole.y), holeRadiusPixels, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw button screw heads on outer holes
                const buttonRadius = this.toPixels(hw.buttonScrew.headDiameter / 2);
                const socketRadius = this.toPixels(1.5 / 25.4); // ~1.5mm hex socket

                outerHoleIndices.forEach(index => {
                    const hole = holes[index];
                    const hx = this.toPixelX(hole.x);
                    const hy = this.toPixelY(hole.y);

                    // Draw button head (circle)
                    ctx.beginPath();
                    ctx.arc(hx, hy, buttonRadius, 0, Math.PI * 2);
                    ctx.fillStyle = CONFIG.colors.buttonScrewHead;
                    ctx.fill();
                    ctx.strokeStyle = CONFIG.colors.buttonScrewHeadStroke;
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    // Draw hex socket in center
                    this.drawHexagon(hx, hy, socketRadius, CONFIG.colors.buttonScrewSocket);
                });
            },

            /**
             * Draw all 4 brackets in top view (2 per pipe)
             */
            drawBracketsTop() {
                // Left pipe brackets
                this.drawBracketTop(0, 'top', true);
                this.drawBracketTop(0, 'bottom', true);
                // Right pipe brackets
                this.drawBracketTop(State.pipeDistance, 'top', false);
                this.drawBracketTop(State.pipeDistance, 'bottom', false);
            },

            /**
             * Draw a bracket in front view (thin rectangle on top of pipe)
             * @param {number} xPipeInnerEdge - X position of the pipe's inner edge in inches
             * @param {boolean} isLeft - true for left pipe bracket, false for right
             */
            drawBracketFront(xPipeInnerEdge, isLeft) {
                const ctx = this.ctx;
                const b = CONFIG.bracket;

                // Get optimal shift from Layout module (same as top view)
                const shiftInfo = Layout.optimalShift();
                const shift = shiftInfo.shift;

                let bracketCenterX;
                if (isLeft) {
                    bracketCenterX = xPipeInnerEdge - shift;
                } else {
                    bracketCenterX = xPipeInnerEdge + shift;
                }
                const bracketX = bracketCenterX - b.width / 2;

                const x = this.toPixelX(bracketX);
                const y = this.toPixelY(-b.thickness);  // Just above y=0 (top of pipe)
                const width = this.toPixels(b.width);
                const height = this.toPixels(b.thickness);

                this.fillRect(x, y, width, height, CONFIG.colors.bracket);
                this.strokeRect(x, y, width, height, CONFIG.colors.bracketStroke, 1);
            },

            /**
             * Draw button screw head in front view (showing it must clear shelf)
             * @param {number} xPipeInnerEdge - X position of pipe center in inches
             * @param {boolean} isLeft - true for left pipe bracket, false for right
             */
            drawButtonScrewFront(xPipeInnerEdge, isLeft) {
                const ctx = this.ctx;
                const b = CONFIG.bracket;
                const hw = CONFIG.hardware;

                // Get optimal shift from Layout module
                const shiftInfo = Layout.optimalShift();
                const shift = shiftInfo.shift;

                let bracketCenterX;
                if (isLeft) {
                    bracketCenterX = xPipeInnerEdge - shift;
                } else {
                    bracketCenterX = xPipeInnerEdge + shift;
                }
                const bracketX = bracketCenterX - b.width / 2;

                // Outer hole X position
                const outerHoleX = isLeft
                    ? bracketX + b.holeCenter
                    : bracketX + b.width - b.holeCenter;

                // Button screw sits on top of bracket, head extends up toward shelf
                const screwY = -b.thickness - hw.buttonScrew.headHeight;
                const screwWidth = hw.buttonScrew.headDiameter;
                const screwHeight = hw.buttonScrew.headHeight;

                const x = this.toPixelX(outerHoleX - screwWidth / 2);
                const y = this.toPixelY(screwY);
                const width = this.toPixels(screwWidth);
                const height = this.toPixels(screwHeight);

                // Draw button head as rounded rectangle
                ctx.fillStyle = CONFIG.colors.buttonScrewHead;
                ctx.beginPath();
                const radius = height / 2;
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.arc(x + width - radius, y + radius, radius, -Math.PI/2, Math.PI/2);
                ctx.lineTo(x + radius, y + height);
                ctx.arc(x + radius, y + radius, radius, Math.PI/2, -Math.PI/2);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = CONFIG.colors.buttonScrewHeadStroke;
                ctx.lineWidth = 1;
                ctx.stroke();
            },

            /**
             * Draw hex cap nuts hanging below bracket in front view
             * @param {number} xPipeInnerEdge - X position of pipe center in inches
             * @param {boolean} isLeft - true for left pipe bracket, false for right
             */
            drawHexNutsFront(xPipeInnerEdge, isLeft) {
                const ctx = this.ctx;
                const b = CONFIG.bracket;
                const hw = CONFIG.hardware;

                // Get optimal shift from Layout module
                const shiftInfo = Layout.optimalShift();
                const shift = shiftInfo.shift;

                let bracketCenterX;
                if (isLeft) {
                    bracketCenterX = xPipeInnerEdge - shift;
                } else {
                    bracketCenterX = xPipeInnerEdge + shift;
                }
                const bracketX = bracketCenterX - b.width / 2;

                // Outer hole X position (where nut hangs)
                const outerHoleX = isLeft
                    ? bracketX + b.holeCenter
                    : bracketX + b.width - b.holeCenter;

                // Nut hangs below bracket - top of nut at y = 0 (top of pipe)
                const nutWidth = hw.hexCapNut.acrossCorners;
                const nutHeight = hw.hexCapNut.height;
                const facetHeight = hw.hexCapNut.acrossFlats; // Height of hex portion

                const x = this.toPixelX(outerHoleX - nutWidth / 2);
                const y = this.toPixelY(0);  // Top of nut at top of pipe
                const width = this.toPixels(nutWidth);
                const totalHeight = this.toPixels(nutHeight);
                const hexHeight = this.toPixels(facetHeight);
                const domeHeight = totalHeight - hexHeight;

                // Draw hex body (top portion - the threaded part)
                ctx.fillStyle = CONFIG.colors.hexNut;
                ctx.fillRect(x, y, width, hexHeight);
                ctx.strokeStyle = CONFIG.colors.hexNutStroke;
                ctx.lineWidth = 1;
                ctx.strokeRect(x, y, width, hexHeight);

                // Draw inner hex detail (darker lines to show hex shape)
                ctx.strokeStyle = '#8b6508';
                ctx.lineWidth = 1;
                const inset = width * 0.15;
                ctx.beginPath();
                ctx.moveTo(x + inset, y);
                ctx.lineTo(x + inset, y + hexHeight);
                ctx.moveTo(x + width - inset, y);
                ctx.lineTo(x + width - inset, y + hexHeight);
                ctx.stroke();

                // Draw domed cap (bottom portion - the acorn cap)
                const domeRadius = width / 2;
                const domeStartY = y + hexHeight;

                ctx.beginPath();
                ctx.moveTo(x, domeStartY);
                ctx.lineTo(x, domeStartY + domeHeight * 0.3);
                ctx.quadraticCurveTo(x, domeStartY + domeHeight, x + width/2, domeStartY + domeHeight);
                ctx.quadraticCurveTo(x + width, domeStartY + domeHeight, x + width, domeStartY + domeHeight * 0.3);
                ctx.lineTo(x + width, domeStartY);
                ctx.closePath();
                ctx.fillStyle = CONFIG.colors.hexNut;
                ctx.fill();
                ctx.strokeStyle = CONFIG.colors.hexNutStroke;
                ctx.lineWidth = 1;
                ctx.stroke();

                // Add highlight to dome for 3D effect
                ctx.beginPath();
                ctx.arc(x + width/2, domeStartY + domeHeight * 0.6, width * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fill();
            },

            /**
             * Draw both brackets in front view
             */
            drawBracketsFront() {
                this.drawBracketFront(0, true);
                this.drawBracketFront(State.pipeDistance, false);
                // Draw button screw heads on top of brackets
                this.drawButtonScrewFront(0, true);
                this.drawButtonScrewFront(State.pipeDistance, false);
                // Draw hex nuts hanging below brackets
                this.drawHexNutsFront(0, true);
                this.drawHexNutsFront(State.pipeDistance, false);
            },

            /**
             * Draw the main shelf rectangle (centered between pipes)
             */
            drawShelf() {
                const ctx = this.ctx;

                // Shelf is centered between pipes
                // shelfOverhang = how much shelf extends beyond each pipe's inner edge
                const shelfOverhang = (CONFIG.shelf.width - State.pipeDistance) / 2;

                // Shelf left edge position (negative means it extends past left pipe's inner edge)
                const shelfX = -shelfOverhang;

                const x = this.toPixelX(shelfX);
                const y = this.toPixelY(0);
                const width = this.toPixels(CONFIG.shelf.width);
                const height = this.toPixels(CONFIG.shelf.depth);

                // Store bounds for click detection
                this.shelfBounds = { x, y, width, height };

                // Apply opacity
                ctx.globalAlpha = State.shelfOpacity;
                this.fillRect(x, y, width, height, CONFIG.colors.shelf);
                // Draw stroke INSIDE the shelf bounds (inset by half stroke width)
                const strokeWidth = 2;
                const inset = strokeWidth / 2;
                ctx.strokeStyle = CONFIG.colors.shelfStroke;
                ctx.lineWidth = strokeWidth;
                ctx.strokeRect(x + inset, y + inset, width - strokeWidth, height - strokeWidth);
                ctx.globalAlpha = 1.0;
            },

            /**
             * Render everything - pipes first, then shelf on top
             */
            render() {
                this.clear();

                if (State.view === 'top') {
                    this.drawPipes();           // Draw pipes first (underneath)
                    this.drawPipeCenterLines(); // Draw center lines on pipes
                    this.drawBracketsTop();     // Draw brackets on pipes
                    this.drawShelf();           // Draw shelf on top (covers middle of lines and top of brackets)
                } else {
                    // Front view
                    this.drawPipeCircles();           // Draw pipe circles
                    this.drawPipeCircleCenterLines(); // Draw center lines
                    this.drawBracketsFront();         // Draw brackets on top of pipes
                    this.drawShelfFront();            // Draw shelf on top
                }
            }
        };

        // ============================================
        // CONTROLS MODULE - UI controls
        // ============================================
        const Controls = {
            init() {
                const pipeDistanceInput = document.getElementById('pipe-distance');
                const viewToggleBtn = document.getElementById('view-toggle');

                pipeDistanceInput.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    if (!isNaN(value) && value > 0) {
                        State.pipeDistance = value;
                        Renderer.calculateDimensions();
                        Renderer.render();
                        this.updateClearanceDisplay();
                    }
                });

                viewToggleBtn.addEventListener('click', () => {
                    State.view = State.view === 'top' ? 'front' : 'top';
                    viewToggleBtn.textContent = `View: ${State.view === 'top' ? 'Top' : 'Front'}`;
                    Renderer.calculateDimensions();
                    Renderer.render();
                });
            },

            /**
             * Update the clearance display UI
             */
            updateClearanceDisplay() {
                const shiftInfo = Layout.optimalShift();
                const leftClearance = Layout.nutToPipeClearance(true, shiftInfo.shift);
                const rightClearance = Layout.nutToPipeClearance(false, shiftInfo.shift);

                const leftEl = document.getElementById('clearance-left');
                const rightEl = document.getElementById('clearance-right');

                // Format shift info
                const shiftMm = Units.toMm(shiftInfo.shift);
                const minMm = Units.toMm(shiftInfo.minShift);
                const maxMm = Units.toMm(shiftInfo.maxShift);

                if (shiftInfo.hasConflict) {
                    leftEl.textContent = `CONFLICT: Need ${minMm.toFixed(1)}mm shift, max allowed ${maxMm.toFixed(1)}mm`;
                    leftEl.style.color = '#c62828';
                    rightEl.textContent = `Using ${shiftMm.toFixed(1)}mm (inner holes may pass center)`;
                    rightEl.style.color = '#c62828';
                } else {
                    leftEl.textContent = `Shift: ${shiftMm.toFixed(2)}mm (range: ${minMm.toFixed(1)}-${maxMm.toFixed(1)}mm)`;
                    leftEl.style.color = '#2e7d32';
                    rightEl.textContent = leftClearance.isOk ? 'Nut clearance: OK' : 'Nut clearance: Check';
                    rightEl.style.color = leftClearance.isOk ? '#2e7d32' : '#ff9800';
                }
            }
        };

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            Renderer.init();
            Controls.init();
            Renderer.render();
            Controls.updateClearanceDisplay();

            // Handle window resize
            window.addEventListener('resize', () => {
                Renderer.calculateDimensions();
                Renderer.render();
            });

            // Log dimensions for verification
            console.log('Shelf Measure initialized');
            console.log('Shelf:', Units.formatInches(CONFIG.shelf.width, true), 'x', Units.formatInches(CONFIG.shelf.depth, true));
            console.log('Pipe diameter:', Units.formatInches(CONFIG.pipe.diameter, true));
            console.log('Pipe distance:', Units.formatInches(State.pipeDistance, true));
            console.log('Scale:', Renderer.scale.toFixed(2), 'pixels per inch');
            const inset = Layout.bracketInsetDepth();
            const gap = CONFIG.shelf.depth - 2 * inset - 2 * CONFIG.bracket.length;
            console.log('Bracket inset (depth):', Units.formatInches(inset, true));
            console.log('Bracket gap between (depth):', Units.formatInches(gap, true));

            // Log clearance info
            const shiftInfo = Layout.optimalShift();
            console.log('Bracket shift:', Units.formatInches(shiftInfo.shift, true));
            console.log('Min shift (button head):', Units.formatInches(shiftInfo.minShiftButtonHead, true));
            console.log('Min shift (nut clearance):', Units.formatInches(shiftInfo.minShiftNut, true));
            console.log('Max shift (inner holes):', Units.formatInches(shiftInfo.maxShift, true));
            if (shiftInfo.hasConflict) {
                console.warn('CONFLICT: Required min shift exceeds max allowed!');
                console.warn(`Need ${Units.toMm(shiftInfo.minShift).toFixed(2)}mm, max allowed ${Units.toMm(shiftInfo.maxShift).toFixed(2)}mm`);
            }
        }

        // Start the app when DOM is ready
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
