<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shelf Measure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #f5f5f5;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #canvas-container {
            background: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        #controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        #controls label {
            font-size: 14px;
            color: #333;
        }
        #controls input {
            width: 120px;
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
        }
        #controls span {
            font-size: 14px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <canvas id="shelf-canvas"></canvas>
    </div>
    <div id="controls">
        <label for="pipe-distance">Pipe Distance:</label>
        <input type="number" id="pipe-distance" step="0.00001" value="28.96875">
        <span>inches</span>
        <button id="view-toggle" style="margin-left: 20px; padding: 6px 12px; border: 1px solid #ccc; border-radius: 4px; background: #fff; cursor: pointer;">View: Top</button>
    </div>

    <script>
        // ============================================
        // CONFIG - All measurements in inches
        // ============================================
        const CONFIG = {
            shelf: {
                width: 30,
                depth: 12,
                height: 1  // For front view
            },
            pipe: {
                diameter: 1.0743,
                length: 13,
                overhang: 0.5  // How much pipe extends beyond shelf top/bottom
            },
            bracket: {
                // All measurements converted from mm to inches
                width: 38 / 25.4,           // 38mm = 1.4961"
                length: 60 / 25.4,          // 60mm = 2.3622" (along pipe)
                thickness: 1.5 / 25.4,      // 1.5mm = 0.05906"
                holeCenter: 8 / 25.4,       // 8mm from edge to hole center = 0.31496"
                holeDiameter: 4.5 / 25.4    // 4.5mm = 0.17717"
            },
            precision: 5,
            mmPerInch: 25.4,
            display: {
                padding: 40,        // Canvas padding in pixels
                minCanvasWidth: 600,
                minCanvasHeight: 300
            },
            colors: {
                shelf: '#d4a574',
                shelfStroke: '#8b6914',
                pipe: '#6b7b8a',
                pipeStroke: '#3d4a54',
                bracket: '#2d2d2d',
                bracketStroke: '#1a1a1a',
                bracketHole: '#ffffff',
                background: '#ffffff'
            }
        };

        // ============================================
        // STATE - Mutable application state
        // ============================================
        const State = {
            pipeDistance: 28.96875,  // Distance between inner edges of pipes
            shelfOpacity: 1.0,       // 1.0 or 0.5
            view: 'top'              // 'top' or 'front'
        };

        // ============================================
        // UNITS MODULE - Conversion utilities
        // ============================================
        const Units = {
            /**
             * Convert inches to millimeters
             * @param {number} inches
             * @returns {number}
             */
            toMm(inches) {
                return inches * CONFIG.mmPerInch;
            },

            /**
             * Convert millimeters to inches
             * @param {number} mm
             * @returns {number}
             */
            toInches(mm) {
                return mm / CONFIG.mmPerInch;
            },

            /**
             * Format a value with precision
             * @param {number} value
             * @param {string} unit - 'in' or 'mm'
             * @returns {string}
             */
            format(value, unit = 'in') {
                const formatted = value.toFixed(CONFIG.precision);
                return `${formatted} ${unit}`;
            },

            /**
             * Format inches value, optionally showing both units
             * @param {number} inches
             * @param {boolean} showBoth
             * @returns {string}
             */
            formatInches(inches, showBoth = false) {
                if (showBoth) {
                    const mm = this.toMm(inches);
                    return `${inches.toFixed(CONFIG.precision)}" (${mm.toFixed(CONFIG.precision)} mm)`;
                }
                return `${inches.toFixed(CONFIG.precision)}"`;
            }
        };

        // ============================================
        // RENDERER MODULE - Canvas drawing
        // ============================================
        const Renderer = {
            canvas: null,
            ctx: null,
            scale: 1,       // Pixels per inch
            offsetX: 0,     // Offset to center drawing
            offsetY: 0,

            // Cached shelf bounds for click detection
            shelfBounds: { x: 0, y: 0, width: 0, height: 0 },

            /**
             * Initialize the renderer
             */
            init() {
                this.canvas = document.getElementById('shelf-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.calculateDimensions();
                this.setupClickHandler();
            },

            /**
             * Setup click handler for shelf opacity toggle
             */
            setupClickHandler() {
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // Check if click is within shelf bounds
                    if (x >= this.shelfBounds.x &&
                        x <= this.shelfBounds.x + this.shelfBounds.width &&
                        y >= this.shelfBounds.y &&
                        y <= this.shelfBounds.y + this.shelfBounds.height) {
                        // Toggle opacity
                        State.shelfOpacity = State.shelfOpacity === 1.0 ? 0.5 : 1.0;
                        this.render();
                    }
                });

                // Change cursor when hovering over shelf
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (x >= this.shelfBounds.x &&
                        x <= this.shelfBounds.x + this.shelfBounds.width &&
                        y >= this.shelfBounds.y &&
                        y <= this.shelfBounds.y + this.shelfBounds.height) {
                        this.canvas.style.cursor = 'pointer';
                    } else {
                        this.canvas.style.cursor = 'default';
                    }
                });
            },

            /**
             * Calculate canvas size and scale
             */
            calculateDimensions() {
                const pipeRadius = CONFIG.pipe.diameter / 2;
                const bracketExtension = CONFIG.bracket.length / 2;  // How much bracket extends past shelf

                // Total width = pipe distance + full diameter on each side (for the pipes extending outside)
                const totalWidth = State.pipeDistance + CONFIG.pipe.diameter;

                // Total height depends on view
                let totalHeight;
                if (State.view === 'top') {
                    // Need to fit: pipe overhang at top + shelf depth + bracket extension at bottom
                    totalHeight = CONFIG.pipe.overhang + CONFIG.shelf.depth + bracketExtension;
                } else {
                    // Front view: bracket thickness + pipe diameter + shelf height
                    totalHeight = CONFIG.bracket.thickness + CONFIG.pipe.diameter + CONFIG.shelf.height;
                }

                // Calculate scale to fit within viewport with padding
                const availableWidth = Math.max(window.innerWidth - 100, CONFIG.display.minCanvasWidth);
                const availableHeight = Math.max(window.innerHeight - 150, CONFIG.display.minCanvasHeight);

                const scaleX = (availableWidth - CONFIG.display.padding * 2) / totalWidth;
                const scaleY = (availableHeight - CONFIG.display.padding * 2) / totalHeight;
                this.scale = Math.min(scaleX, scaleY);

                // Set canvas size (use integers to avoid blur)
                this.canvas.width = Math.round(totalWidth * this.scale + CONFIG.display.padding * 2);
                this.canvas.height = Math.round(totalHeight * this.scale + CONFIG.display.padding * 2);

                // Offset so that x=0 is at the left pipe's inner edge
                this.offsetX = CONFIG.display.padding + pipeRadius * this.scale;

                if (State.view === 'top') {
                    this.offsetY = CONFIG.display.padding + CONFIG.pipe.overhang * this.scale;
                } else {
                    // Front view: y=0 is at top of pipe circles
                    // Bracket sits above pipe (at -thickness), shelf sits above bracket
                    this.offsetY = CONFIG.display.padding + (CONFIG.bracket.thickness + CONFIG.shelf.height) * this.scale;
                }
            },

            /**
             * Convert inches to canvas pixels (X coordinate) - returns rounded integer
             * @param {number} inches
             * @returns {number}
             */
            toPixelX(inches) {
                return Math.round(this.offsetX + inches * this.scale);
            },

            /**
             * Convert inches to canvas pixels (Y coordinate) - returns rounded integer
             * @param {number} inches
             * @returns {number}
             */
            toPixelY(inches) {
                return Math.round(this.offsetY + inches * this.scale);
            },

            /**
             * Convert inches to pixels (for dimensions) - returns rounded integer
             * @param {number} inches
             * @returns {number}
             */
            toPixels(inches) {
                return Math.round(inches * this.scale);
            },

            /**
             * Clear the canvas
             */
            clear() {
                this.ctx.fillStyle = CONFIG.colors.background;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            },

            /**
             * Draw a crisp rectangle (for fills)
             */
            fillRect(x, y, width, height, color) {
                this.ctx.fillStyle = color;
                this.ctx.fillRect(x, y, width, height);
            },

            /**
             * Draw a crisp stroked rectangle
             * Offset by 0.5 to align stroke to pixel grid
             */
            strokeRect(x, y, width, height, color, lineWidth) {
                const ctx = this.ctx;
                ctx.strokeStyle = color;
                ctx.lineWidth = lineWidth;
                // Offset by 0.5 for crisp 1px lines
                const offset = lineWidth % 2 === 1 ? 0.5 : 0;
                ctx.strokeRect(x + offset, y + offset, width, height);
            },

            /**
             * Draw a single pipe
             * @param {number} xInnerEdge - X position of the pipe's inner edge in inches
             */
            drawPipe(xInnerEdge) {
                const pipeRadius = CONFIG.pipe.diameter / 2;

                // Pipe position: inner edge at xInnerEdge
                const x = this.toPixelX(xInnerEdge - pipeRadius);
                const y = this.toPixelY(-CONFIG.pipe.overhang);
                const width = this.toPixels(CONFIG.pipe.diameter);
                const height = this.toPixels(CONFIG.pipe.length);

                this.fillRect(x, y, width, height, CONFIG.colors.pipe);
                this.strokeRect(x, y, width, height, CONFIG.colors.pipeStroke, 1);
            },

            /**
             * Draw both pipe supports
             */
            drawPipes() {
                // Left pipe: inner edge at x = 0
                this.drawPipe(0);

                // Right pipe: inner edge at x = pipeDistance
                this.drawPipe(State.pipeDistance);
            },

            /**
             * Draw center line on a pipe
             * @param {number} xInnerEdge - X position of the pipe's inner edge in inches
             */
            drawPipeCenterLine(xInnerEdge) {
                const ctx = this.ctx;
                const pipeRadius = CONFIG.pipe.diameter / 2;

                // Center of pipe
                const x = Math.round(this.toPixelX(xInnerEdge)) + 0.5; // 0.5 offset for crisp 1px line
                const yStart = this.toPixelY(-CONFIG.pipe.overhang);
                const yEnd = this.toPixelY(-CONFIG.pipe.overhang + CONFIG.pipe.length);

                ctx.beginPath();
                ctx.moveTo(x, yStart);
                ctx.lineTo(x, yEnd);
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 1;
                ctx.stroke();
            },

            /**
             * Draw center lines on both pipes (top view)
             */
            drawPipeCenterLines() {
                // Left pipe center line
                this.drawPipeCenterLine(0);

                // Right pipe center line
                this.drawPipeCenterLine(State.pipeDistance);
            },

            // ========== FRONT VIEW METHODS ==========

            /**
             * Draw a pipe as a circle (front view)
             * @param {number} xInnerEdge - X position of the pipe's inner edge in inches
             */
            drawPipeCircle(xInnerEdge) {
                const ctx = this.ctx;
                const pipeRadius = CONFIG.pipe.diameter / 2;

                // Circle center
                const cx = this.toPixelX(xInnerEdge);
                const cy = this.toPixelY(pipeRadius);
                const r = this.toPixels(pipeRadius);

                ctx.beginPath();
                ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.fillStyle = CONFIG.colors.pipe;
                ctx.fill();
                ctx.strokeStyle = CONFIG.colors.pipeStroke;
                ctx.lineWidth = 1;
                ctx.stroke();
            },

            /**
             * Draw both pipe circles (front view)
             */
            drawPipeCircles() {
                this.drawPipeCircle(0);
                this.drawPipeCircle(State.pipeDistance);
            },

            /**
             * Draw center line on a pipe circle (front view) - vertical line through center
             * @param {number} xInnerEdge - X position of the pipe's inner edge in inches
             */
            drawPipeCircleCenterLine(xInnerEdge) {
                const ctx = this.ctx;
                const pipeRadius = CONFIG.pipe.diameter / 2;

                const x = Math.round(this.toPixelX(xInnerEdge)) + 0.5;
                const yStart = this.toPixelY(0);
                const yEnd = this.toPixelY(CONFIG.pipe.diameter);

                ctx.beginPath();
                ctx.moveTo(x, yStart);
                ctx.lineTo(x, yEnd);
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 1;
                ctx.stroke();
            },

            /**
             * Draw center lines on both pipe circles (front view)
             */
            drawPipeCircleCenterLines() {
                this.drawPipeCircleCenterLine(0);
                this.drawPipeCircleCenterLine(State.pipeDistance);
            },

            /**
             * Draw shelf in front view (rectangle above pipes and brackets)
             */
            drawShelfFront() {
                const ctx = this.ctx;

                // Shelf is centered between pipes
                const shelfOverhang = (CONFIG.shelf.width - State.pipeDistance) / 2;
                const shelfX = -shelfOverhang;

                const x = this.toPixelX(shelfX);
                // Shelf sits above the bracket (which is above the pipe)
                const y = this.toPixelY(-CONFIG.bracket.thickness - CONFIG.shelf.height);
                const width = this.toPixels(CONFIG.shelf.width);
                const height = this.toPixels(CONFIG.shelf.height);

                // Store bounds for click detection
                this.shelfBounds = { x, y, width, height };

                // Apply opacity
                ctx.globalAlpha = State.shelfOpacity;
                this.fillRect(x, y, width, height, CONFIG.colors.shelf);
                this.strokeRect(x, y, width, height, CONFIG.colors.shelfStroke, 2);
                ctx.globalAlpha = 1.0;
            },

            // ========== BRACKET METHODS ==========

            /**
             * Draw a bracket in top view (rectangle with 4 holes)
             * @param {number} xPipeInnerEdge - X position of the pipe's inner edge in inches
             * @param {boolean} isLeft - true for left bracket, false for right
             */
            drawBracketTop(xPipeInnerEdge, isLeft) {
                const ctx = this.ctx;
                const b = CONFIG.bracket;

                // Bracket is centered on pipe (x-axis) and straddles shelf bottom edge (y-axis)
                // The bracket's center aligns with the pipe center (inner edge)
                const bracketCenterX = xPipeInnerEdge;
                const bracketCenterY = CONFIG.shelf.depth;  // Bottom edge of shelf

                const bracketX = bracketCenterX - b.width / 2;
                const bracketY = bracketCenterY - b.length / 2;

                const x = this.toPixelX(bracketX);
                const y = this.toPixelY(bracketY);
                const width = this.toPixels(b.width);
                const height = this.toPixels(b.length);

                // Draw bracket rectangle
                this.fillRect(x, y, width, height, CONFIG.colors.bracket);
                this.strokeRect(x, y, width, height, CONFIG.colors.bracketStroke, 1);

                // Draw 4 holes (2x2 pattern)
                // Holes are 8mm from each edge
                const holeRadius = this.toPixels(b.holeDiameter / 2);
                const holeOffsetX = b.holeCenter;  // From bracket edge
                const holeOffsetY = b.holeCenter;  // From bracket edge

                // Hole positions relative to bracket top-left
                const holes = [
                    { x: bracketX + holeOffsetX, y: bracketY + holeOffsetY },                           // Top-left
                    { x: bracketX + b.width - holeOffsetX, y: bracketY + holeOffsetY },                 // Top-right
                    { x: bracketX + holeOffsetX, y: bracketY + b.length - holeOffsetY },                // Bottom-left
                    { x: bracketX + b.width - holeOffsetX, y: bracketY + b.length - holeOffsetY }       // Bottom-right
                ];

                ctx.fillStyle = CONFIG.colors.bracketHole;
                holes.forEach(hole => {
                    ctx.beginPath();
                    ctx.arc(this.toPixelX(hole.x), this.toPixelY(hole.y), holeRadius, 0, Math.PI * 2);
                    ctx.fill();
                });
            },

            /**
             * Draw both brackets in top view
             */
            drawBracketsTop() {
                this.drawBracketTop(0, true);                    // Left bracket
                this.drawBracketTop(State.pipeDistance, false); // Right bracket
            },

            /**
             * Draw a bracket in front view (thin rectangle on top of pipe)
             * @param {number} xPipeInnerEdge - X position of the pipe's inner edge in inches
             */
            drawBracketFront(xPipeInnerEdge) {
                const ctx = this.ctx;
                const b = CONFIG.bracket;

                // Bracket sits on top of the pipe circle
                const bracketCenterX = xPipeInnerEdge;
                const bracketX = bracketCenterX - b.width / 2;

                const x = this.toPixelX(bracketX);
                const y = this.toPixelY(-b.thickness);  // Just above y=0 (top of pipe)
                const width = this.toPixels(b.width);
                const height = this.toPixels(b.thickness);

                this.fillRect(x, y, width, height, CONFIG.colors.bracket);
                this.strokeRect(x, y, width, height, CONFIG.colors.bracketStroke, 1);
            },

            /**
             * Draw both brackets in front view
             */
            drawBracketsFront() {
                this.drawBracketFront(0);
                this.drawBracketFront(State.pipeDistance);
            },

            /**
             * Draw the main shelf rectangle (centered between pipes)
             */
            drawShelf() {
                const ctx = this.ctx;

                // Shelf is centered between pipes
                // shelfOverhang = how much shelf extends beyond each pipe's inner edge
                const shelfOverhang = (CONFIG.shelf.width - State.pipeDistance) / 2;

                // Shelf left edge position (negative means it extends past left pipe's inner edge)
                const shelfX = -shelfOverhang;

                const x = this.toPixelX(shelfX);
                const y = this.toPixelY(0);
                const width = this.toPixels(CONFIG.shelf.width);
                const height = this.toPixels(CONFIG.shelf.depth);

                // Store bounds for click detection
                this.shelfBounds = { x, y, width, height };

                // Apply opacity
                ctx.globalAlpha = State.shelfOpacity;
                this.fillRect(x, y, width, height, CONFIG.colors.shelf);
                this.strokeRect(x, y, width, height, CONFIG.colors.shelfStroke, 2);
                ctx.globalAlpha = 1.0;
            },

            /**
             * Render everything - pipes first, then shelf on top
             */
            render() {
                this.clear();

                if (State.view === 'top') {
                    this.drawPipes();           // Draw pipes first (underneath)
                    this.drawPipeCenterLines(); // Draw center lines on pipes
                    this.drawBracketsTop();     // Draw brackets on pipes
                    this.drawShelf();           // Draw shelf on top (covers middle of lines and top of brackets)
                } else {
                    // Front view
                    this.drawPipeCircles();           // Draw pipe circles
                    this.drawPipeCircleCenterLines(); // Draw center lines
                    this.drawBracketsFront();         // Draw brackets on top of pipes
                    this.drawShelfFront();            // Draw shelf on top
                }
            }
        };

        // ============================================
        // CONTROLS MODULE - UI controls
        // ============================================
        const Controls = {
            init() {
                const pipeDistanceInput = document.getElementById('pipe-distance');
                const viewToggleBtn = document.getElementById('view-toggle');

                pipeDistanceInput.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    if (!isNaN(value) && value > 0) {
                        State.pipeDistance = value;
                        Renderer.calculateDimensions();
                        Renderer.render();
                    }
                });

                viewToggleBtn.addEventListener('click', () => {
                    State.view = State.view === 'top' ? 'front' : 'top';
                    viewToggleBtn.textContent = `View: ${State.view === 'top' ? 'Top' : 'Front'}`;
                    Renderer.calculateDimensions();
                    Renderer.render();
                });
            }
        };

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            Renderer.init();
            Controls.init();
            Renderer.render();

            // Handle window resize
            window.addEventListener('resize', () => {
                Renderer.calculateDimensions();
                Renderer.render();
            });

            // Log dimensions for verification
            console.log('Shelf Measure initialized');
            console.log('Shelf:', Units.formatInches(CONFIG.shelf.width, true), 'x', Units.formatInches(CONFIG.shelf.depth, true));
            console.log('Pipe diameter:', Units.formatInches(CONFIG.pipe.diameter, true));
            console.log('Pipe distance:', Units.formatInches(State.pipeDistance, true));
            console.log('Scale:', Renderer.scale.toFixed(2), 'pixels per inch');
        }

        // Start the app when DOM is ready
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
